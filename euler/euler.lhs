Project Euler
=============

  > Project Euler is a series of challenging mathematical/computer programming
  problems that will require more than just mathematical insights to solve.
  Although mathematics will help you arrive at elegant and efficient methods,
  the use of a computer and programming skills will be required to solve most
  problems. -- http://projecteuler.net

This is my attempt at them.

Both sample input and expected answers (after they have been solved) will be
expressed as HUnit tests at the bottom of the file.

> import Test.HUnit

List functions will be used extensively.

> import List

Problem 1
---------

  > If we list all the natural numbers below 10 that are multiples of 3 or 5,
  we get 3, 5, 6 and 9. The sum of these multiples is 23.

  > Find the sum of all the multiples of 3 or 5 below 1000.

> eulerOne max = sum . nub $ (multiplesOf 3) ++ (multiplesOf 5)
>   where  multiplesOf x = [x,x*2..max-1]

> testsOne =
>   [ "#1 given"   ~: 23 ~=? eulerOne 10
>   , "#1 problem" ~: 233168 ~=? eulerOne 1000
>   ]

Problem 2
---------

 > Each new term in the Fibonacci sequence is generated by adding the previous
 two terms. By starting with 1 and 2, the first 10 terms will be:

 > 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

 > By considering the terms in the Fibonacci sequence whose values do not
 exceed four million, find the sum of the even-valued terms.

Start by defining an efficient infinite sequence to generate Fibonacci values.

> fibonacci = seq 0 1 where seq x y = (x+y):(seq y (x+y))

From there, the solution is trivial.

> eulerTwo max = sum $ filter even $ takeWhile (<= max) fibonacci

> testsTwo =
>   [ "#2 test"    ~: 44      ~=? eulerTwo 40
>   , "#2 problem" ~: 4613732 ~=? eulerTwo 4000000
>   ]

Problem 3
---------

 > The prime factors of 13195 are 5, 7, 13 and 29.

 > What is the largest prime factor of the number 600851475143?

If we start from 2 and work up, dividing the target by found factors as we go,
then any factors we find will necessarily be prime: the factor "4" cannot be
found because we would have already found the factor "2" twice.

With this fact, we can write a solution without any explicit check for
"primeness" that simply accumulates factors until we have reached the target.

> primeFactors n n' p
>   | n' == 1       = []
>   | rem n' p == 0 = p:(primeFactors n (n' `div` p) p)
>   | otherwise     = primeFactors n n' (p + 1)

> eulerThree x = last $ primeFactors x x 2

> testsThree =
>   [ "#3 test"    ~: 29   ~=? eulerThree 13195
>   , "#3 problem" ~: 6857 ~=? eulerThree 600851475143
>   ]

Problem 4
---------

 > A palindromic number reads the same both ways. The largest palindrome made
 > from the product of two 2-digit numbers is 9009 = 91 99.

 > Find the largest palindrome made from the product of two 3-digit numbers.

The input set is relatively small, so it would suffice to generate a list of
all possible numbers and filter them. This can generate a solution on my
machine in approximately two seconds.

A solution with more finesse is possible.

It is know that the answer will be six digits long (maximum length of two
3-digit numbers multiplied), and will be of the form:

      100000a + 10000b + 1000c + 100c + 10b + a
    = 100001a + 10010b + 1100c
    = 11(9091a + 910b + 110c)

This tells us that the answer must be divisible by 11, which allows the input
set to be trimmed considerably, yielding an order of magnitude speed up.

Intuitively, the maximum palindrome will be the result of two digits in the
nine hundred range, which allows us to scope the search space even further.
While this may be presumptious, if no solution is found it is easy enough to
drop the lower bound.

> palindrome x = x' == reverse x' where x' = show x

> eulerFour r = maximum $ [x * y | x <- r, y <- r', palindrome $ x * y]
>   where
>     r' = [x | x <- r, rem x 11 == 0]

> testsFour =
>   [ "#4 test"    ~: 9009   ~=? eulerFour [10..99]
>   , "#4 problem" ~: 906609 ~=? eulerFour [900..999]
>   ]

Epilogue
--------

Run all given test cases as the main function of this file.

> main = runTestTT $ TestList ( testsOne
>                            ++ testsTwo
>                            ++ testsThree
>                            ++ testsFour
>                             )
